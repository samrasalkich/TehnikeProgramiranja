//TP 2021/2022: ZadaÄ‡a 4, Zadatak 1

#include <iostream>
#include <cmath>
#include <tuple>
#include <stdexcept>
#include <memory>
#include <new>
#include <vector>
#include <algorithm>
#define EPS std::pow(10,-10)
#define PI 4*std::atan(1);


class Kugla {
    double x,y,z,r;

    void TestPoluprecnika(double poluprecnik) {
        if (poluprecnik < 0)
            throw std::domain_error("Ilegalan poluprecnik");
    }

public:

    explicit Kugla(double r = 0);
    Kugla(double x, double y, double z, double r = 0);
    explicit Kugla(const std::tuple<double, double, double> &centar, double r = 0);

    double DajX() const { return x; }
    double DajY() const { return y; }
    double DajZ() const { return z; }
    std::tuple<double, double, double> DajCentar() const { return std::make_tuple(x,y,z); }
    double DajPoluprecnik() const { return r; }
    double DajPovrsinu() const { return 4*std::pow(r,2)*PI; }
    double DajZapreminu() const { return (4./3)*std::pow(r,3)*PI; }

    Kugla &PostaviX(double x) { Kugla::x = x; return *this; }
    Kugla &PostaviY(double y) { Kugla::y = y; return *this; }
    Kugla &PostaviZ(double z) { Kugla::z = z; return *this; }
    Kugla &PostaviCentar(double x, double y, double z);
    Kugla &PostaviCentar(const std::tuple<double, double, double> &centar);
    Kugla &PostaviPoluprecnik(double r);

    void Ispisi() const;
    void Transliraj(double delta_x, double delta_y, double delta_z);
    friend bool DaLiSuIdenticne(const Kugla &k1, const Kugla &k2);
    friend bool DaLiSuPodudarne(const Kugla &k1, const Kugla &k2);
    friend bool DaLiSuKoncentricne(const Kugla &k1, const Kugla &k2);
    friend bool DaLiSeDodirujuIzvana(const Kugla &k1, const Kugla &k2);
    friend bool DaLiSeDodirujuIznutra(const Kugla &k1, const Kugla &k2);
    friend bool DaLiSePreklapaju(const Kugla &k1, const Kugla &k2);
    friend bool DaLiSeSijeku(const Kugla &k1, const Kugla &k2);
    bool DaLiSadrzi(const Kugla &k) const;
    friend double RastojanjeCentara(const Kugla &k1, const Kugla &k2);

};


Kugla::Kugla(double r) : x(0), y(0), z(0) {
    TestPoluprecnika(r);
    Kugla::r = r;
}

Kugla::Kugla(double x, double y, double z, double r) {
    TestPoluprecnika(r);
    Kugla::x = x;
    Kugla::y = y;
    Kugla::z = z;
    Kugla::r = r;
}

Kugla::Kugla(const std::tuple<double,double,double> &centar, double r) {
    TestPoluprecnika(r);
    x = std::get<0>(centar);
    y = std::get<1>(centar);
    z = std::get<2>(centar);
    Kugla::r = r;
}

Kugla &Kugla::PostaviCentar(double x, double y, double z) {
    Kugla::x = x;
    Kugla::y = y;
    Kugla::z = z;
    return *this;
}

Kugla &Kugla::PostaviCentar(const std::tuple<double,double,double> &centar) {
    x = std::get<0>(centar);
    y = std::get<1>(centar);
    z = std::get<2>(centar);
    return *this;
}

Kugla &Kugla::PostaviPoluprecnik(double r) {
    TestPoluprecnika(r);
    Kugla::r = r;
    return *this;
}

void Kugla::Ispisi() const {
    std::cout << "{(" << DajX() << "," << DajY() << "," << DajZ() << ")," << DajPoluprecnik() << "}" << std::endl;
}

void Kugla::Transliraj(double delta_x, double delta_y, double delta_z) {
    x += delta_x;
    y += delta_y;
    z += delta_z;
}

bool DaLiJeJednako(double a, double b) {
    return (std::fabs(a-b) < EPS);
}

bool DaLiSuPodudarne(const Kugla &k1, const Kugla &k2) {
    return DaLiJeJednako(k1.r,k2.r);
}

bool DaLiSuKoncentricne(const Kugla &k1, const Kugla &k2) {
    return (DaLiJeJednako(k1.x,k2.x) && DaLiJeJednako(k1.y,k2.y) && DaLiJeJednako(k1.z,k2.z));
}

bool DaLiSuIdenticne(const Kugla &k1, const Kugla &k2) {
    return (DaLiSuPodudarne(k1,k2) && DaLiSuKoncentricne(k1,k2));
}

double RastojanjeCentara(const Kugla &k1, const Kugla &k2) {
    return std::sqrt(std::pow(k2.x-k1.x,2) + std::pow(k2.y-k1.y,2) + std::pow(k2.z-k1.z,2));
}

bool DaLiSeDodirujuIzvana(const Kugla &k1, const Kugla &k2) {
    return (DaLiJeJednako(RastojanjeCentara(k1,k2), k1.r + k2.r));
}

bool DaLiSeDodirujuIznutra(const Kugla &k1, const Kugla &k2) {
    if (k1.r > k2.r) 
        return (DaLiJeJednako(RastojanjeCentara(k1,k2), k1.r - k2.r));
    else 
        return (DaLiJeJednako(RastojanjeCentara(k1,k2), k2.r - k1.r));
}

bool DaLiSePreklapaju(const Kugla &k1, const Kugla &k2) {
    return (DaLiJeJednako(k1.DajPovrsinu(),k2.DajPovrsinu()) && DaLiSeSijeku(k1,k2));
}

bool Kugla::DaLiSadrzi(const Kugla &k) const {
    return (RastojanjeCentara(k,*this) + k.r < this->r || DaLiJeJednako(RastojanjeCentara(k,*this) + k.r, this->r));
}

bool DaLiSeSijeku(const Kugla &k1, const Kugla &k2) {
    return (RastojanjeCentara(k1,k2) > (k1.r - k2.r) && RastojanjeCentara(k1,k2) < (k1.r + k2.r) && !DaLiSeDodirujuIznutra(k1,k2));
}


typedef std::shared_ptr<Kugla> Pok;

int main ()
{   
    try {
        int n;
        Kugla k;
        double x,y,z,r;

        std::cout << "Unesite broj kugla: ";
        std::cin >> n;

        std::vector<Pok> v(n);

        for (int i=0; i<n; i++) {
            std::cout << "Unesite centar " << i+1 << ". kugle: ";
            std::cin >> x >> y >> z;

            std::cout << "Unesite poluprecnik " << i+1 << ". kugle: ";
            std::cin >> r;

            if (r < 0 || !std::cin) {
                std::cout << "Ilegalan poluprecnik" << std::endl;
                i--;
            }
                else {
                    std::shared_ptr<Kugla> p(new Kugla(x,y,z,r));
                    v.at(i) = p;
                }
        }

        double dx,dy,dz;
        std::cout << "Unesite parametre translacije (delta_x,delta_y,delta_z): ";
        std::cin >> dx >> dy >> dz;
        std::transform(v.begin(), v.end(), v.begin(), [dx,dy,dz] (Pok p) { p->Transliraj(dx,dy,dz); return p; });
        std::sort(v.begin(), v.end(), [](Pok p1, Pok p2) { return p1->DajZapreminu() < p2->DajZapreminu();});

        std::cout << "Kugle nakon obavljenje transformacije imaju sljedece vrijednosti: " << std::endl;
        std::for_each(v.begin(), v.end(), [](Pok p) { p->Ispisi();});
    	
        auto k1 = *std::max_element(v.begin(), v.end(), [](Pok p1, Pok p2) { return p1->DajPovrsinu() < p2->DajPovrsinu(); });
        std::cout << "Kugla sa najvecom povrsinom je: ";
        k1->Ispisi();

        int i=0;
        bool postoji = false;
        std::for_each(v.begin(), v.end(), [v,&i,&postoji](Pok p1) {  
            std::for_each(v.begin()+i, v.end(), [p1, &postoji](Pok p2) {
                if (DaLiSeSijeku(*p1,*p2)) {
                    postoji = true;
                    std::cout << "Presjecaju se kugle: ";
                    p1->Ispisi(); p2->Ispisi();
                }
            });
            i++;
        });

        if (!postoji)
            std::cout << "Ne postoje kugle koje se presjecaju!";

    } catch (std::domain_error e) {
        std::cout << e.what();
    } catch (...) {
        std::cout << "Pogresan izuzetak";
    }

	return 0;

}
